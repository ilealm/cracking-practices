# Iris Leal, cracking practices


[My Resume](cracking_practices/resume/resume.md)

## Table of Contents

[Partition - 2.4](cracking_practices/partition/README.md)

- Write code to partition a linked list around a value X, such that all nodes less than X come before all nodes greater than or equal to X. If X is contained within the list, the value of X only needs to after the element less than X. The partition element X can appear anywhere in the "right partition", it does not need to appear between the left and right partitions.

[Sum List - 2.5](cracking_practices/sum_list/README.md)

- You have 2 numbers represented by 2 linked list, where each node contains a single digit. The digits are stored in reverse order, such that the 1st digit is at the head of the list. White a function that adds the 2 numbers and returns the sum as a linked list.


[Palindrome in Linked List - 2.6](cracking_practices/palindrome_ll/README.md)

- Implement a function to check is a linked list is a palindrome. Each node contains a letter of the word to check.


[Interseccion - 2.7](cracking_practices/intersection/README.md)
- Given two singly linked list, determine if the two lists intersect. Return the intersecting node. Note that the intersection is based on reference, not value. That is, if the kth value node on the first ll is the exact same node (by reference) as the jth node on the second ll, then, they are intersecting.

[Loop Detection - 2.8](cracking_practices/loop_detection/README.md)
- Given a circular linked list, implement an algorithm that returns the node at the beginning of the loop.

[Run Length Encoding ](cracking_practices/run_length_encoding/README.md)
- Create a function that receives a string and returns the run-length encoding of it.


[Is unique - 1.1](cracking_practices/is_unique/README.md)
- Implement an algorithm to determinate if a string has all unique characters.


[URLify - 1.3](cracking_practices/URLify/README.md)
- Write a method to replace all the white spaces in a str_to_url with '%20'. You may assume that the str_to_url has sufficient space at the end to hold the additional characters
and that you are given the true length of the str_to_url.


[One Away - 1.5](cracking_practices/one_way/README.md)
- There are three types of edits that can be performed on strings: insert a character,  remove a character, or replace a character. Given two strings,  write a function to check if they are one edit or zero edits away. Return true or false.

[Rotate Matix - 1.7](cracking_practices/rotate_matix_90/README.md)
- Given an image represented by an NxN matrix, where each pixel in the image is 4 bytes. Write a method to rotate the image by 90 degrees.

[String Rotation 1.9](cracking_practices/string_rotation/README.md)
- Given two strings, s1 and s2, write code to check if s2 is a rotation of s1 using only one call to isSubstrig.

[Fibonacci](cracking_practices/fibonacci/README.md)
- Given a number, return its value in the fibonacci sequence.

[Reverse String](cracking_practices/reverse_string/README.md)
- Given a string, return it in reverse order.

[Return Ordered List](cracking_practices/return_ordered_list/README.md)
- Having a list of thousands of unordered numbers from 1 - 100, return an ordered list with all these values.

[Merge Sort List](cracking_practices/merge_sort/README.md)
- Given a unsorted list with integer values, sorted in place using Merge Sort.

[Quick Sort List](cracking_practices/quick_sort/README.md)
- Given a unsorted list with integer values, sorted in place using Quick Sort.

[Binary Tree Zig Zag](cracking_practices/zig_zag_tree/README.md)
- Having a binary search tree, return the values in a zig zag fashion.

[Minimal Tree 4.2](cracking_practices/minimal_tree/README.md)
- Given a sorted (increasing order) array with unique integer elements, white an algorithm to create a binary search tree with minimal height.

[List of Depths 4.3](cracking_practices/list_of_depths/README.md)
- Given a binary tree, design an algorithm that creates a link list of all the nodes at each level depth. If you have a tree with deep D, you will have D linked list.

[Validate BST 4.5](cracking_practices/validate_bst/README.md)
- Implement a function that checks if a binary tree is a BST

[Check Balanced 4.4](cracking_practices/check_balanced/README.md)
- Implement a function to check if a binary tree is balanced. For the purpose of this question, a balanced tree is defined to be a tree such as the hights of the two subtrees of any node never differ by more than one.

[Successor 4.6](cracking_practices/successor/README.md)
- Write an algorithm to find the "next" node (i.e in-order successor) of a given node in a BST. You may assume that each node has a link to its parent.

[Get Node Path](cracking_practices/get_node_path/README.md)
- Write a function that returns in a list the path of a node in the tree, from the lower level to root. It receives a tree and a node, to search its value in the tree. * It can return a Stack() object if required.


[First Common Ancestor 4.8](cracking_practices/first_common_ancestor/README.md)
- Design an algorithm and write the code to find the first common ancestor of two nodes in a binary tree. Avoid storing additional nodes in the data structure. NOTE: This is not necessarily a binary search tree.

[Permutations](cracking_practices/permutations/README.md)
- Given an array, return all the possibles permutations of it.

[Join Two Orderder Lists ](cracking_practices/join_two_lists/README.md)
- Given two ordered list, return a lists with all the elements sorted.

[BST Sequence 4.9 ](cracking_practices/bst_sequences/README.md)
- A binary search tree was created by traversing a through an array from left to right and inserting each element. Given a binary search tree with distinct elements, print all possible arrays that could have lead to this tree.

[Check Subtree 4.10](cracking_practices/check_subtree/README.md)
- T1 and T2 are two very large binary trees, with T1 much bigger than T2. Create an algorithm to determine if T2 is a subtree of T1. A tree T2 is a subtree of T1 if there exists a node n in T1 such that the subtree of n is identical to T2. That is, if you cut off the tree at node n, the new two trees would be identical.

[Average Subarrays](cracking_practices/average_subarrays/README.md)
- Given an array, find the average of all contiguous subarrays of size ‘K’ in it.

[Maximum Subarrays](cracking_practices/max_sub_array/README.md)
- Given an array of positive numbers and a positive number ‘k’, find the maximum sum of any contiguous subarray of size ‘k’.

[Smallest Subarray with a given sum](cracking_practices/smallest_subarray/README.md)
- Given an array of positive numbers and a positive number ‘S’, find the length of the smallest contiguous subarray whose sum is greater than or equal to ‘S’.

[ Longest Substring with K Distinct Characters ](cracking_practices/longest_substring/README.md)
- Given a string, find the length of the longest substring in it with no more than K distinct characters.

[ Fruits into Baskets ](cracking_practices/fruits_into_baskets/README.md)
- Given an array of characters where each character represents a fruit tree, you are given two baskets and your goal is to put maximum number of fruits in each basket. The only restriction is that each basket can have only one type of fruit.

[ No Repeat Substring ](cracking_practices/no_repeat_substring/README.md)
- Given a string, find the length of the longest substring which has no repeating characters.

[ Longest Substring with Same Letters after Replacement ](cracking_practices/longest_subsrt_w_replacement/README.md)
- Given a string with lowercase letters only, if you are allowed to replace no more than ‘k’ letters with any letter, find the length of the longest substring having the same letters after replacement.

[ Longest Subarray with Ones after Replacement ](cracking_practices/longest_subsrt_w_1s_replacement/README.md)
- Given an array containing 0s and 1s, if you are allowed to replace no more than ‘k’ 0s with 1s, find the length of the longest contiguous subarray having all 1s.

[ Permutation in a String ](cracking_practices/permutation_in_a_str/README.md)
- Given a string and a pattern, find out if the string contains any permutation of the pattern.

[ String Anagrams ](cracking_practices/string_anagrams/README.md)
- Given a string and a pattern, find all anagrams of the pattern in the given string.

[ Smallest Window containing Substring ](cracking_practices/smallest_containing_substrig/README.md)
- Given a string and a pattern, find the smallest substring in the given string which has all the characters of the given pattern.

[ Words Concatenation ](cracking_practices/words_concatenation/README.md)
- Given a string and a list of words, find all the starting indices of substrings in the given string that are a concatenation of all the given words exactly once without any overlapping of words. It is given that all words are of the same length.

[ Pair with Target Sum ](cracking_practices/pair_with_target_sum/README.md)
- Given an array of sorted numbers and a target sum, find a pair in the array whose sum is equal to the given target. Write a function to return the indices of the two numbers (i.e. the pair) such that they add up to the given target.
