# Iris Leal, cracking practices


[My Resume](cracking_practices/resume/resume.md)

## Table of Contents

[Partition - 2.4](cracking_practices/partition/README.md)

- Write code to partition a linked list around a value X, such that all nodes less than X come before all nodes greater than or equal to X. If X is contained within the list, the value of X only needs to after the element less than X. The partition element X can appear anywhere in the "right partition", it does not need to appear between the left and right partitions.

[Sum List - 2.5](cracking_practices/sum_list/README.md)

- You have 2 numbers represented by 2 linked list, where each node contains a single digit. The digits are stored in reverse order, such that the 1st digit is at the head of the list. White a function that adds the 2 numbers and returns the sum as a linked list.


[Palindrome in Linked List - 2.6](cracking_practices/palindrome_ll/README.md)

- Implement a function to check is a linked list is a palindrome. Each node contains a letter of the word to check.


[Interseccion - 2.7](cracking_practices/intersection/README.md)
- Given two singly linked list, determine if the two lists intersect. Return the intersecting node. Note that the intersection is based on reference, not value. That is, if the kth value node on the first ll is the exact same node (by reference) as the jth node on the second ll, then, they are intersecting.

[Loop Detection - 2.8](cracking_practices/loop_detection/README.md)
- Given a circular linked list, implement an algorithm that returns the node at the beginning of the loop.

[Run Length Encoding ](cracking_practices/run_length_encoding/README.md)
- Create a function that receives a string and returns the run-length encoding of it.


[Is unique - 1.1](cracking_practices/is_unique/README.md)
- Implement an algorithm to determinate if a string has all unique characters.


[URLify - 1.3](cracking_practices/URLify/README.md)
- Write a method to replace all the white spaces in a str_to_url with '%20'. You may assume that the str_to_url has sufficient space at the end to hold the additional characters
and that you are given the true length of the str_to_url.


[One Away - 1.5](cracking_practices/one_way/README.md)
- There are three types of edits that can be performed on strings: insert a character,  remove a character, or replace a character. Given two strings,  write a function to check if they are one edit or zero edits away. Return true or false.

[Rotate Matix - 1.7](cracking_practices/rotate_matix_90/README.md)
- Given an image represented by an NxN matrix, where each pixel in the image is 4 bytes. Write a method to rotate the image by 90 degrees.

[String Rotation 1.9](cracking_practices/string_rotation/README.md)
- Given two strings, s1 and s2, write code to check if s2 is a rotation of s1 using only one call to isSubstrig.

[Fibonacci](cracking_practices/fibonacci/README.md)
- Given a number, return its value in the fibonacci sequence.

[Reverse String](cracking_practices/reverse_string/README.md)
- Given a string, return it in reverse order.

[Return Ordered List](cracking_practices/return_ordered_list/README.md)
- Having a list of thousands of unordered numbers from 1 - 100, return an ordered list with all these values.

[Merge Sort List](cracking_practices/merge_sort/README.md)
- Given a unsorted list with integer values, sorted in place using Merge Sort.

[Quick Sort List](cracking_practices/quick_sort/README.md)
- Given a unsorted list with integer values, sorted in place using Quick Sort.

[Binary Tree Zig Zag](cracking_practices/zig_zag_tree/README.md)
- Having a binary search tree, return the values in a zig zag fashion.

[Minimal Tree 4.2](cracking_practices/minimal_tree/README.md)
- Given a sorted (increasing order) array with unique integer elements, white an algorithm to create a binary search tree with minimal height.

[List of Depths 4.3](cracking_practices/list_of_depths/README.md)
- Given a binary tree, design an algorithm that creates a link list of all the nodes at each level depth. If you have a tree with deep D, you will have D linked list.

[Validate BST 4.5](cracking_practices/validate_bst/README.md)
- Implement a function that checks if a binary tree is a BST

[Check Balanced 4.4](cracking_practices/check_balanced/README.md)
- Implement a function to check if a binary tree is balanced. For the purpose of this question, a balanced tree is defined to be a tree such as the hights of the two subtrees of any node never differ by more than one.

[Successor 4.6](cracking_practices/successor/README.md)
- Write an algorithm to find the "next" node (i.e in-order successor) of a given node in a BST. You may assume that each node has a link to its parent.

[Get Node Path](cracking_practices/get_node_path/README.md)
- Write a function that returns in a list the path of a node in the tree, from the lower level to root. It receives a tree and a node, to search its value in the tree. * It can return a Stack() object if required.


[First Common Ancestor 4.8](cracking_practices/first_common_ancestor/README.md)
- Design an algorithm and write the code to find the first common ancestor of two nodes in a binary tree. Avoid storing additional nodes in the data structure. NOTE: This is not necessarily a binary search tree.

[Permutations](cracking_practices/permutations/README.md)
- Given an array, return all the possibles permutations of it.

[Join Two Orderder Lists ](cracking_practices/join_two_lists/README.md)
- Given two ordered list, return a lists with all the elements sorted.

[BST Sequence 4.9 ](cracking_practices/bst_sequences/README.md)
- A binary search tree was created by traversing a through an array from left to right and inserting each element. Given a binary search tree with distinct elements, print all possible arrays that could have lead to this tree.

[Check Subtree 4.10](cracking_practices/check_subtree/README.md)
- T1 and T2 are two very large binary trees, with T1 much bigger than T2. Create an algorithm to determine if T2 is a subtree of T1. A tree T2 is a subtree of T1 if there exists a node n in T1 such that the subtree of n is identical to T2. That is, if you cut off the tree at node n, the new two trees would be identical.

[Average Subarrays](cracking_practices/average_subarrays/README.md)
- Given an array, find the average of all contiguous subarrays of size ‘K’ in it.

[Maximum Subarrays](cracking_practices/max_sub_array/README.md)
- Given an array of positive numbers and a positive number ‘k’, find the maximum sum of any contiguous subarray of size ‘k’.

[Smallest Subarray with a given sum](cracking_practices/smallest_subarray/README.md)
- Given an array of positive numbers and a positive number ‘S’, find the length of the smallest contiguous subarray whose sum is greater than or equal to ‘S’.

[ Longest Substring with K Distinct Characters ](cracking_practices/longest_substring/README.md)
- Given a string, find the length of the longest substring in it with no more than K distinct characters.

[ Fruits into Baskets ](cracking_practices/fruits_into_baskets/README.md)
- Given an array of characters where each character represents a fruit tree, you are given two baskets and your goal is to put maximum number of fruits in each basket. The only restriction is that each basket can have only one type of fruit.

[ No Repeat Substring ](cracking_practices/no_repeat_substring/README.md)
- Given a string, find the length of the longest substring which has no repeating characters.

[ Longest Substring with Same Letters after Replacement ](cracking_practices/longest_subsrt_w_replacement/README.md)
- Given a string with lowercase letters only, if you are allowed to replace no more than ‘k’ letters with any letter, find the length of the longest substring having the same letters after replacement.

[ Longest Subarray with Ones after Replacement ](cracking_practices/longest_subsrt_w_1s_replacement/README.md)
- Given an array containing 0s and 1s, if you are allowed to replace no more than ‘k’ 0s with 1s, find the length of the longest contiguous subarray having all 1s.

[ Permutation in a String ](cracking_practices/permutation_in_a_str/README.md)
- Given a string and a pattern, find out if the string contains any permutation of the pattern.

[ String Anagrams ](cracking_practices/string_anagrams/README.md)
- Given a string and a pattern, find all anagrams of the pattern in the given string.

[ Smallest Window containing Substring ](cracking_practices/smallest_containing_substrig/README.md)
- Given a string and a pattern, find the smallest substring in the given string which has all the characters of the given pattern.

[ Words Concatenation ](cracking_practices/words_concatenation/README.md)
- Given a string and a list of words, find all the starting indices of substrings in the given string that are a concatenation of all the given words exactly once without any overlapping of words. It is given that all words are of the same length.

[ Pair with Target Sum ](cracking_practices/pair_with_target_sum/README.md)
- Given an array of sorted numbers and a target sum, find a pair in the array whose sum is equal to the given target. Write a function to return the indices of the two numbers (i.e. the pair) such that they add up to the given target.

[ Remove Duplicates ](cracking_practices/remove_duplicates/README.md)
- Given an array of sorted numbers, remove all duplicates from it. You should not use any extra space; after removing the duplicates in-place return the length of the subarray that has no duplicate in it.

[ Squaring a Sorted Array ](cracking_practices/squaring_a_sorted_array/README.md)
- Given a sorted array, create a new array containing squares of all the number of the input array in the sorted order.

[ Triplet Sum to Zero ](cracking_practices/triplet_sum_to_zero/README.md)
- Given an array of unsorted numbers, find all unique triplets in it that add up to zero.

[ Triplet Sum Close to Target ](cracking_practices/triplet_sum_close_to_target/README.md)
- Given an array of unsorted numbers and a target number, find a triplet in the array whose sum is as
close to the target number as possible, return the sum of the triplet. If there are more than one such
triplet, return the sum of the triplet with the smallest sum.

[ Triplets with Smaller Sum ](cracking_practices/triplets_with_smaller_sum/README.md)
- Given an array arr of unsorted numbers and a target sum, count all triplets in it such that arr[i] + arr[j] + arr[k] < target where i, j, and k are three different indices. Write a function to return the count of such triplets.

[ Subarrays with Product Less than a Target ](cracking_practices/subarrays_w_product_less_than_target/README.md)
- Given an array with positive numbers and a target number, find all of its contiguous subarrays whose product is less than the target number.

[ Dutch National Flag Problem ](cracking_practices/dutch_national_flag/README.md)
- Given an array containing 0s, 1s and 2s, sort the array in-place. You should treat numbers of the array as objects, hence, we can’t count 0s, 1s, and 2s to recreate the array.

[ Quadruple Sum to Target ](cracking_practices/quadruple_sum_to_target/README.md)
- Given an array of unsorted numbers and a target number, find all unique quadruplets in it, whose sum is equal to the target number.

[ Comparing Strings containing Backspaces ](cracking_practices/comparing_str_with_baskspaces/README.md)
- Given two strings containing backspaces (identified by the character ‘#’), check if the two strings are equal.

[ Minimum Window Sort ](cracking_practices/minimum_window_sort/README.md)
- Given an array, find the length of the smallest subarray in it which when sorted will sort the whole array.

[ LinkedList Cycle ](cracking_practices/linked_list_cycle/README.md)
- Given the head of a Singly LinkedList, write a function to determine if the LinkedList has a cycle in it or not.

[ LinkedList Cycle Length ](cracking_practices/linked_list_cycle_length/README.md)
- Given the head of a LinkedList with a cycle, find the length of the cycle.

[ Start of LinkedList Cycle ](cracking_practices/linked_list_cycle_length/README.md)
- Given the head of a Singly LinkedList that contains a cycle, write a function to find the starting node of the cycle.


[ Happy Number ](cracking_practices/happy_number/README.md)
- Any number will be called a happy number if, after repeatedly replacing it with a number equal to the sum of the
square of all of its digits, leads us to number ‘1’. All other (not-happy) numbers will never reach ‘1’.
Instead, they will be stuck in a cycle of numbers which does not include ‘1’.

[ Middle of the LinkedList ](cracking_practices/middle_of_linkedlist/README.md)
- Given the head of a Singly LinkedList, write a method to return the middle node of the LinkedList.
If the total number of nodes in the LinkedList is even, return the second middle node.

[ Palindrome LinkedList ](cracking_practices/palindrome_singly_ll/README.md)
- Given the head of a Singly LinkedList, write a method to check if the LinkedList is a palindrome or not.
Your algorithm should use constant space and the input LinkedList should be in the original form once
the algorithm is finished. The algorithm should have O(N)O(N) time complexity where ‘N’ is the number of nodes in the LinkedList.

[ Rearrange a LinkedList ](cracking_practices/rearrange_linkedlist/README.md)
- Given the head of a Singly LinkedList, write a method to modify the LinkedList such that the nodes from the second half
of the LinkedList are inserted alternately to the nodes from the first half in reverse order. So if the LinkedList has
nodes 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> null, your method should return 1 -> 6 -> 2 -> 5 -> 3 -> 4 -> null.

Your algorithm should not use any extra space and the input LinkedList should be modified in-place.

[ Cycle in a Circular Array ](cracking_practices/cycle_in_circular_array/README.md)
- We are given an array containing positive and negative numbers. Suppose the array contains a number ‘M’ at a particular index. Now, if ‘M’ is positive we will move forward ‘M’ indices and if ‘M’ is negative move backwards ‘M’ indices. You should assume that the array is circular which means two things:

If, while moving forward, we reach the end of the array, we will jump to the first element to continue the movement.
If, while moving backward, we reach the beginning of the array, we will jump to the last element to continue the movement.
Write a method to determine if the array has a cycle. The cycle should have more than one element and should follow one direction which means the cycle should not contain both forward and backward movements.

[ Merge Intervals ](cracking_practices/merge_intervals/README.md)
- Given a list of intervals, merge all the overlapping intervals to produce a list that has only mutually exclusive intervals.

[ Insert Interval ](cracking_practices/insert_interval/README.md)
- Given a list of non-overlapping intervals sorted by their start time, insert a given interval at the correct position and
merge all necessary intervals to produce a list that has only mutually exclusive intervals.

[ Intervals Intersection ](cracking_practices/intervals_intersection/README.md)
- Given two lists of intervals, find the intersection of these two lists. Each list consists of disjoint intervals sorted on their start time.

[ Conflicting Appointments ](cracking_practices/conflicting_appointments/README.md)
- Given an array of intervals representing ‘N’ appointments, find out if a person can attend all the appointments.

[ Minimum Meeting Rooms ](cracking_practices/mininum_meetings_rooms/README.md)
- Given a list of intervals representing the start and end time of ‘N’ meetings, find the minimum number of rooms required to hold all the meetings.

[ Maximum CPU Load ](cracking_practices/maximum_cpu_load/README.md)
- We are given a list of Jobs. Each job has a Start time, an End time, and a CPU load when it is running.
Our goal is to find the maximum CPU load at any time if all the jobs are running on the same machine.

[ Employee Free Time](cracking_practices/employee_free_time/README.md)
- For ‘K’ employees, we are given a list of intervals representing each employee’s working hours. Our goal is to determine if there is a free interval which is common to all employees. You can assume that each list of employee working hours is sorted on the start time.

[ Cyclic Sort ](cracking_practices/cyclic_sort/README.md)
- We are given an array containing ‘n’ objects. Each object, when created, was assigned a unique number from 1 to ‘n’ based on their creation sequence. This means that the object with sequence number ‘3’ was created just before the object with sequence number ‘4’.
Write a function to sort the objects in-place on their creation sequence number in O(n)O(n) and without any extra space. For simplicity, let’s assume we are passed an integer array containing only the sequence numbers, though each number is actually an object.

[ Find the Missing Number ](cracking_practices/find_missing_number/README.md)
- We are given an array containing ‘n’ distinct numbers taken from the range 0 to ‘n’. Since the array has only ‘n’ numbers out of the total ‘n+1’ numbers, find the missing number.

[ Find All Missing Number ](cracking_practices/find_all_missing_numbers/README.md)
- We are given an unsorted array containing numbers taken from the range 1 to ‘n’. The array can have duplicates, which means some numbers will be missing. Find all those missing numbers.


[ Find the Duplicate Number ](cracking_practices/find_all_missing_numbers/README.md)
- We are given an unsorted array containing ‘n+1’ numbers taken from the range 1 to ‘n’. The array has only one duplicate but it can be repeated multiple times. Find that duplicate number without using any extra space. You are, however, allowed to modify the input array.

[ Find all Duplicate Numbers ](cracking_practices/find_all_duplicate_numbers/README.md)
- We are given an unsorted array containing ‘n’ numbers taken from the range 1 to ‘n’. The array has some numbers appearing twice, find all these duplicate numbers without using any extra space.

[ Find the Corrupt Pair ](cracking_practices/find_the_corrupt_pair/README.md)
- We are given an unsorted array containing ‘n’ numbers taken from the range 1 to ‘n’. The array originally contained all the numbers from 1 to ‘n’, but due to a data error, one of the numbers got duplicated which also resulted in one number going missing. Find both these numbers.

[ Find the Smallest Missing Positive Number ](cracking_practices/find_smallest_missing_possitive_number/README.md)
- Given an unsorted array containing numbers, find the smallest missing positive number in it.

[ Find the First K Missing Positive Numbers ](cracking_practices/find_first_k_missing_positive/README.md)
- Given an unsorted array containing numbers and a number ‘k’, find the first ‘k’ missing positive numbers in the array.

[ Implement Binary Search in a List ](cracking_practices/binary_search/README.md)
- Given an sorted array containing numbers or letters, using binary search return the value's index. If the value is not found, then returns -1.


[ Implement a Selection Sort to sort a List ](cracking_practices/selection_sort/README.md)
- Given a unsorted list, return the same list in an ordered fashion using Selection Sort.

[ Reverse a List in Place ](cracking_practices/reverse_list_in_place/README.md)
- Create a function that receives a list and return the same list but with the elements in inverted order, without any extra space (in place).

[ Exersices with recursion ](cracking_practices/recursion/README.md)
- Using Recursion, get the sum of all elements in an array, get the number of elements in an array, find the bigest number of elements in an array and applying binary search, find a value in a list. If the value is not there, return -1.


[ QuickSort with Comprenhension List ](cracking_practices/quick_sort_v2/README.md)
- This solution implements Quick Sort, but instead of using a helper Partition funtion to sort the less and greater values in the array, this solution implements List Comprenhension istead.


[ Class Scheduling ](cracking_practices/class_scheduling/README.md)
- You have a classroom and a schedule, and want to hold as many classes there as possible. Some clases may overlap, so you need to arrainge the classes in the most optimal way. The original schedule is insorted.


[ Reverse Linked List in place ](cracking_practices/linked_list_reverse/README.md)
- Having a linked list, reverse it using O(n) in time and O(1) in space.


[ kth Element from a Linked List ](cracking_practices/linked_list_kth_from_end/README.md)
- Using a linked list, return the kth node value from the end.  Use O(n) for time and space.


[ Middle Element from a Linked List ](cracking_practices/linked_list_get_middle/README.md)
- Using a linked list, return the middle node value from the end.  Use O(n) for time and space.


[ Is a valid expresion? (Implemented with Stacks) ](cracking_practices/check_expresion_stacks/README.md)
- Given a expresion, return True if the opening tags "({<" has their closed tag in the right possition.


[ Implement two stacks in one array. ](cracking_practices/two_stacks_in_one_array/README.md)
- Support these operations:  push1(), to push in the first stack; push2(), to push in the second stack; pop1(), pop2(), isEmpty1(), isEmpty2(), isFull1(), isFull2(). Make sure your implementation is space efficient. (hint: do not allocate the same amount of space by dividing the array in half.)
