# Iris Leal, cracking practices


[My Resume](cracking_practices/resume/resume.md)

## Table of Contents

[Partition - 2.4](cracking_practices/partition/README.md)

- Write code to partition a linked list around a value X, such that all nodes less than X come before all nodes greater than or equal to X. If X is contained within the list, the value of X only needs to after the element less than X. The partition element X can appear anywhere in the "right partition", it does not need to appear between the left and right partitions.

[Sum List - 2.5](cracking_practices/sum_list/README.md)

- You have 2 numbers represented by 2 linked list, where each node contains a single digit. The digits are stored in reverse order, such that the 1st digit is at the head of the list. White a function that adds the 2 numbers and returns the sum as a linked list.


[Palindrome in Linked List - 2.6](cracking_practices/palindrome_ll/README.md)

- Implement a function to check is a linked list is a palindrome. Each node contains a letter of the word to check.


[Interseccion - 2.7](cracking_practices/intersection/README.md)
- Given two singly linked list, determine if the two lists intersect. Return the intersecting node. Note that the intersection is based on reference, not value. That is, if the kth value node on the first ll is the exact same node (by reference) as the jth node on the second ll, then, they are intersecting.

[Loop Detection - 2.8](cracking_practices/loop_detection/README.md)
- Given a circular linked list, implement an algorithm that returns the node at the beginning of the loop.

[Run Length Encoding ](cracking_practices/run_length_encoding/README.md)
- Create a function that receives a string and returns the run-length encoding of it.


[Is unique - 1.1](cracking_practices/is_unique/README.md)
- Implement an algorithm to determinate if a string has all unique characters.


[URLify - 1.3](cracking_practices/URLify/README.md)
- Write a method to replace all the white spaces in a str_to_url with '%20'. You may assume that the str_to_url has sufficient space at the end to hold the additional characters
and that you are given the true length of the str_to_url.


[One Away - 1.5](cracking_practices/one_way/README.md)
- There are three types of edits that can be performed on strings: insert a character,  remove a character, or replace a character. Given two strings,  write a function to check if they are one edit or zero edits away. Return true or false.

[Rotate Matix - 1.7](cracking_practices/rotate_matix_90/README.md)
- Given an image represented by an NxN matrix, where each pixel in the image is 4 bytes. Write a method to rotate the image by 90 degrees.

[String Rotation 1.9](cracking_practices/string_rotation/README.md)
- Given two strings, s1 and s2, write code to check if s2 is a rotation of s1 using only one call to isSubstrig.

[Fibonacci](cracking_practices/fibonacci/README.md)
- Given a number, return its value in the fibonacci sequence.

[Reverse String](cracking_practices/reverse_string/README.md)
- Given a string, return it in reverse order.

[Return Ordered List](cracking_practices/return_ordered_list/README.md)
- Having a list of thousands of unordered numbers from 1 - 100, return an ordered list with all these values.

[Merge Sort List](cracking_practices/merge_sort/README.md)
- Given a unsorted list with integer values, sorted in place using Merge Sort.

[Quick Sort List](cracking_practices/quick_sort/README.md)
- Given a unsorted list with integer values, sorted in place using Quick Sort.

[Binary Tree Zig Zag](cracking_practices/zig_zag_tree/README.md)
- Having a binary search tree, return the values in a zig zag fashion.

[Minimal Tree 4.2](cracking_practices/minimal_tree/README.md)
- Given a sorted (increasing order) array with unique integer elements, white an algorithm to create a binary search tree with minimal height.

[List of Depths 4.3](cracking_practices/list_of_depths/README.md)
- Given a binary tree, design an algorithm that creates a link list of all the nodes at each level depth. If you have a tree with deep D, you will have D linked list.

[Validate BST 4.5](cracking_practices/validate_bst/README.md)
- Implement a function that checks if a binary tree is a BST

[Check Balanced 4.4](cracking_practices/check_balanced/README.md)
- Implement a function to check if a binary tree is balanced. For the purpose of this question, a balanced tree is defined to be a tree such as the hights of the two subtrees of any node never differ by more than one.

[Successor 4.6](cracking_practices/successor/README.md)
- Write an algorithm to find the "next" node (i.e in-order successor) of a given node in a BST. You may assume that each node has a link to its parent.

[Get Node Path](cracking_practices/get_node_path/README.md)
- Write a function that returns in a list the path of a node in the tree, from the lower level to root. It receives a tree and a node, to search its value in the tree. * It can return a Stack() object if required.


[First Common Ancestor 4.8](cracking_practices/first_common_ancestor/README.md)
- Design an algorithm and write the code to find the first common ancestor of two nodes in a binary tree. Avoid storing additional nodes in the data structure. NOTE: This is not necessarily a binary search tree.

[Permutations](cracking_practices/permutations/README.md)
- Given an array, return all the possibles permutations of it.

[Join Two Orderder Lists ](cracking_practices/join_two_lists/README.md)
- Given two ordered list, return a lists with all the elements sorted.

[BST Sequence 4.9 ](cracking_practices/bst_sequences/README.md)
- A binary search tree was created by traversing a through an array from left to right and inserting each element. Given a binary search tree with distinct elements, print all possible arrays that could have lead to this tree.

[Check Subtree 4.10](cracking_practices/check_subtree/README.md)
- T1 and T2 are two very large binary trees, with T1 much bigger than T2. Create an algorithm to determine if T2 is a subtree of T1. A tree T2 is a subtree of T1 if there exists a node n in T1 such that the subtree of n is identical to T2. That is, if you cut off the tree at node n, the new two trees would be identical.

[Average Subarrays](cracking_practices/average_subarrays/README.md)
- Given an array, find the average of all contiguous subarrays of size ‘K’ in it.

[Maximum Subarrays](cracking_practices/max_sub_array/README.md)
- Given an array of positive numbers and a positive number ‘k’, find the maximum sum of any contiguous subarray of size ‘k’.

[Smallest Subarray with a given sum](cracking_practices/smallest_subarray/README.md)
- Given an array of positive numbers and a positive number ‘S’, find the length of the smallest contiguous subarray whose sum is greater than or equal to ‘S’.

[ Longest Substring with K Distinct Characters ](cracking_practices/longest_substring/README.md)
- Given a string, find the length of the longest substring in it with no more than K distinct characters.

[ Fruits into Baskets ](cracking_practices/fruits_into_baskets/README.md)
- Given an array of characters where each character represents a fruit tree, you are given two baskets and your goal is to put maximum number of fruits in each basket. The only restriction is that each basket can have only one type of fruit.

[ No Repeat Substring ](cracking_practices/no_repeat_substring/README.md)
- Given a string, find the length of the longest substring which has no repeating characters.

[ Longest Substring with Same Letters after Replacement ](cracking_practices/longest_subsrt_w_replacement/README.md)
- Given a string with lowercase letters only, if you are allowed to replace no more than ‘k’ letters with any letter, find the length of the longest substring having the same letters after replacement.

[ Longest Subarray with Ones after Replacement ](cracking_practices/longest_subsrt_w_1s_replacement/README.md)
- Given an array containing 0s and 1s, if you are allowed to replace no more than ‘k’ 0s with 1s, find the length of the longest contiguous subarray having all 1s.

[ Permutation in a String ](cracking_practices/permutation_in_a_str/README.md)
- Given a string and a pattern, find out if the string contains any permutation of the pattern.

[ String Anagrams ](cracking_practices/string_anagrams/README.md)
- Given a string and a pattern, find all anagrams of the pattern in the given string.

[ Smallest Window containing Substring ](cracking_practices/smallest_containing_substrig/README.md)
- Given a string and a pattern, find the smallest substring in the given string which has all the characters of the given pattern.

[ Words Concatenation ](cracking_practices/words_concatenation/README.md)
- Given a string and a list of words, find all the starting indices of substrings in the given string that are a concatenation of all the given words exactly once without any overlapping of words. It is given that all words are of the same length.

[ Pair with Target Sum ](cracking_practices/pair_with_target_sum/README.md)
- Given an array of sorted numbers and a target sum, find a pair in the array whose sum is equal to the given target. Write a function to return the indices of the two numbers (i.e. the pair) such that they add up to the given target.

[ Remove Duplicates ](cracking_practices/remove_duplicates/README.md)
- Given an array of sorted numbers, remove all duplicates from it. You should not use any extra space; after removing the duplicates in-place return the length of the subarray that has no duplicate in it.

[ Squaring a Sorted Array ](cracking_practices/squaring_a_sorted_array/README.md)
- Given a sorted array, create a new array containing squares of all the number of the input array in the sorted order.

[ Triplet Sum to Zero ](cracking_practices/triplet_sum_to_zero/README.md)
- Given an array of unsorted numbers, find all unique triplets in it that add up to zero.

[ Triplet Sum Close to Target ](cracking_practices/triplet_sum_close_to_target/README.md)
- Given an array of unsorted numbers and a target number, find a triplet in the array whose sum is as
close to the target number as possible, return the sum of the triplet. If there are more than one such
triplet, return the sum of the triplet with the smallest sum.

[ Triplets with Smaller Sum ](cracking_practices/triplets_with_smaller_sum/README.md)
- Given an array arr of unsorted numbers and a target sum, count all triplets in it such that arr[i] + arr[j] + arr[k] < target where i, j, and k are three different indices. Write a function to return the count of such triplets.

[ Subarrays with Product Less than a Target ](cracking_practices/subarrays_w_product_less_than_target/README.md)
- Given an array with positive numbers and a target number, find all of its contiguous subarrays whose product is less than the target number.

[ Dutch National Flag Problem ](cracking_practices/dutch_national_flag/README.md)
- Given an array containing 0s, 1s and 2s, sort the array in-place. You should treat numbers of the array as objects, hence, we can’t count 0s, 1s, and 2s to recreate the array.

[ Quadruple Sum to Target ](cracking_practices/quadruple_sum_to_target/README.md)
- Given an array of unsorted numbers and a target number, find all unique quadruplets in it, whose sum is equal to the target number.

[ Comparing Strings containing Backspaces ](cracking_practices/comparing_str_with_baskspaces/README.md)
- Given two strings containing backspaces (identified by the character ‘#’), check if the two strings are equal.

[ Minimum Window Sort ](cracking_practices/minimum_window_sort/README.md)
- Given an array, find the length of the smallest subarray in it which when sorted will sort the whole array.

[ LinkedList Cycle ](cracking_practices/linked_list_cycle/README.md)
- Given the head of a Singly LinkedList, write a function to determine if the LinkedList has a cycle in it or not.

[ LinkedList Cycle Length ](cracking_practices/linked_list_cycle_length/README.md)
- Given the head of a LinkedList with a cycle, find the length of the cycle.

[ Start of LinkedList Cycle ](cracking_practices/linked_list_cycle_length/README.md)
- Given the head of a Singly LinkedList that contains a cycle, write a function to find the starting node of the cycle.


[ Happy Number ](cracking_practices/happy_number/README.md)
- Any number will be called a happy number if, after repeatedly replacing it with a number equal to the sum of the
square of all of its digits, leads us to number ‘1’. All other (not-happy) numbers will never reach ‘1’.
Instead, they will be stuck in a cycle of numbers which does not include ‘1’.

[ Middle of the LinkedList ](cracking_practices/middle_of_linkedlist/README.md)
- Given the head of a Singly LinkedList, write a method to return the middle node of the LinkedList.
If the total number of nodes in the LinkedList is even, return the second middle node.

[ Palindrome LinkedList ](cracking_practices/palindrome_singly_ll/README.md)
- Given the head of a Singly LinkedList, write a method to check if the LinkedList is a palindrome or not.
Your algorithm should use constant space and the input LinkedList should be in the original form once
the algorithm is finished. The algorithm should have O(N)O(N) time complexity where ‘N’ is the number of nodes in the LinkedList.

[ Rearrange a LinkedList ](cracking_practices/rearrange_linkedlist/README.md)
- Given the head of a Singly LinkedList, write a method to modify the LinkedList such that the nodes from the second half
of the LinkedList are inserted alternately to the nodes from the first half in reverse order. So if the LinkedList has
nodes 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> null, your method should return 1 -> 6 -> 2 -> 5 -> 3 -> 4 -> null.

Your algorithm should not use any extra space and the input LinkedList should be modified in-place.
